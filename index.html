<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rebar Serial Coloring Tool</title>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
  <style>
    body { padding: 1rem; font-family: Arial, sans-serif; background: #f8f9fa; height: 100vh; display: flex; flex-direction: column; }
    h3 { margin-bottom: 1rem; }
    #status { margin: 1rem 0; font-weight: bold; font-size: 1.1rem; }
    .btn { margin: 0.25rem; }
    .info { margin-top: auto; font-size: 0.9rem; color: #666; }
  </style>
</head>
<body>

  <h3>Rebar Serial Coloring Tool</h3>

  <div id="status" class="text-info">Connecting to viewer...</div>

  <div>
    <button class="btn btn-info btn-lg btn-block" onclick="debugProperties()">
      Debug Selected Properties (Open Console F12)
    </button>
    <button class="btn btn-primary btn-lg btn-block" onclick="colorBySerial()">
      Color Selected by Serial Number
    </button>
    <button class="btn btn-warning btn-lg btn-block" onclick="resetColors()">
      Reset Colors
    </button>
  </div>

  <div class="info mt-4">
    <p><strong>How to use:</strong></p>
    <ol>
      <li>Select rebar bars.</li>
      <li>Click <strong>Debug Selected Properties</strong> → press F12 → Console tab → see exact pset names (e.g., "ICOS Rebar").</li>
      <li>Update SERIAL_PSET below if needed.</li>
      <li>Click <strong>Color Selected by Serial Number</strong> → same serial = same color.</li>
    </ol>
  </div>

  <script>
    let workspaceApi = null;
    let viewer = null;
    const statusEl = document.getElementById('status');

    // UPDATE THESE AFTER DEBUGGING
    let SERIAL_PSET = "ICOS Rebar";  // Try "ICOS_Rebar", "ICOS BBS", etc. from console
    let SERIAL_PROP = "Serial number";

    async function initExtension() {
      try {
        workspaceApi = await TrimbleConnectWorkspace.connect(window.parent);
        viewer = workspaceApi.viewer;
        statusEl.textContent = "Connected – Ready to use!";
        statusEl.className = "text-success";
      } catch (error) {
        statusEl.textContent = "Connection failed: " + (error?.message || error);
        statusEl.className = "text-danger";
        console.error(error);
      }
    }

    async function debugProperties() {
      if (!viewer) return alert("Not connected");
      const sel = await viewer.getSelection();
      if (!sel.length) return alert("Select rebar first");

      const objects = await viewer.getObjects({ selected: true });
      console.clear();
      console.log("%c=== REBAR PROPERTIES DEBUG ===", "font-weight:bold; color:blue");

      for (const model of objects) {
        const ids = model.objects.map(o => o.id);
        const props = await viewer.getObjectProperties({ modelId: model.modelId, objectRuntimeIds: ids });

        props.forEach((obj, i) => {
          console.log(`\nObject ${i+1}`);
          const psets = obj.properties?.propertySets || [];
          psets.forEach(ps => {
            console.log(`%cPset: "${ps.name}"`, "font-weight:bold; color:green");
            ps.properties.forEach(p => console.log(`  • ${p.name}: ${p.value}`));
          });
        });
      }
      alert("Check console (F12) for exact pset/property names!");
    }

    const serialColorMap = new Map();

    function randomColor() {
      return { r: Math.floor(Math.random() * 256), g: Math.floor(Math.random() * 256), b: Math.floor(Math.random() * 256) };
    }

    async function colorBySerial() {
      if (!viewer) return alert("Not connected");

      const selection = await viewer.getSelection();
      if (!selection.length) return alert("Select rebar first");

      const basicObjects = await viewer.getObjects({ selected: true });
      let processed = 0;

      for (const model of basicObjects) {
        const runtimeIds = model.objects.map(obj => obj.id);
        if (runtimeIds.length === 0) continue;

        const fullObjects = await viewer.getObjectProperties({ modelId: model.modelId, objectRuntimeIds: runtimeIds });

        for (const obj of fullObjects) {
          const psets = obj.properties?.propertySets || [];
          const serialPset = psets.find(ps => ps.name === SERIAL_PSET);
          if (!serialPset) continue;

          const serialProp = serialPset.properties?.find(p => p.name === SERIAL_PROP);
          const serial = serialProp?.value?.toString();
          if (!serial) continue;

          let color = serialColorMap.get(serial);
          if (!color) {
            color = randomColor();
            serialColorMap.set(serial, color);
          }

          await viewer.setObjectState(
            { modelObjectIds: [{ modelId: model.modelId, objectRuntimeIds: [obj.id] }] },
            { color }
          );
          processed++;
        }
      }

      if (processed === 0) alert(`No "${SERIAL_PROP}" found in "${SERIAL_PSET}" pset – use Debug button to check names`);
      else alert(`Colored ${processed} rebar(s) by serial number`);
    }

    async function resetColors() {
      if (!viewer) return;
      try {
        await viewer.setObjectState(undefined, { color: null });
        serialColorMap.clear();
        alert("Colors reset");
      } catch (e) {
        alert("Reset failed");
      }
    }

    initExtension();
  </script>
</body>
</html>